#Developing for Multiple Environments and Screens

Producing an application that is functional, usable, and beautiful across all devices is 
the holy grail of application development.  With Ext JS 6 you now have the tools you need 
to achieve this goal with minimal difficulty. 

Creating an application that meets all of these requirements can be accomplished in a few 
different ways.  

## Universal Applications and Toolkits

One of the biggest changes in Ext JS 6 is the merging of Ext JS and Touch into a single 
framework containing two distinct toolkits: classic and modern.  These toolkits contain 
the view layers from Ext JS and Touch.  Applications that share core resources and logic 
and utilize both toolkits are called Universal applications.

To select the application's toolkit, users simply adjust their Sencha Cmd generated 
application’s `app.json` as follows:

    "toolkit": "classic", // or "modern"

The core of both frameworks (data, controllers, models, etc) has been reconciled into a 
singular, common platform. This allows for shared data and logic, which can help developers 
optimize their applications even further.  

**Note**: We'll talk about each toolkit in further detail below.

If you're not familiar with `app.json`, it's a list of configs that is the core of 
your application.  

The `app.json` file generated by Sencha Cmd contains many properties that you may want 
to adjust. These properties are documented inline to explain what they each control.

If you are upgrading a project, your app.json may not contain all of the possible options. 
After performing the upgrade, the default values for any missing properties can instead be 
found in ".sencha/app/app.defaults.json". You should not edit that file, but can copy 
pieces from it to your `app.json` file.

For more information about `app.json`, please check out [the microloader guide](../../../../cmd/guides/microloader.html).

### Classic

The classic toolkit provides traditional Ext JS 5 application support.  This includes 
support for the desktop browsers, tablets, and touchscreen enabled laptops.

### Modern

The modern toolkit provides universal HTML5 application support all modern browsers (IE11+) 
from desktop to phone.

### Build Profiles

Build profiles allow developers to create variations of an application based on the `builds` 
object found in an application's `app.json` file.  Historically, users have had the 
opportunity to differentiate builds based on theme and locale.

We talked more about `app.json` above, but for more information, please check out 
[the microloader guide](../../../../cmd/guides/microloader.html).

As of Ext JS 6 and Sencha Cmd 6, developers may now include a `toolkit` key within their 
build configs.  This allows users to set the toolkit to classic or modern (more below).  Cmd 
then loops through each build key and applies the appropriate toolkit and any toolkit 
agnostic logic for each build.  

Toolkit agnostic code includes anything that can be shared between toolkits.  This includes 
anything previously found within the sencha-core package (i.e., data, controllers, etc).  
It's important to note that this shared logic must be usable by both toolkits.  

A `builds` config for a Universal application should look similar to the following 
JSON structure:

    "builds": {

       "mymodern": {

           "toolkit" : "modern",

           "theme"   : "theme-cupertino",

           "requires": [

               "charts",

               "ux"

           ]   

       },

       "myclassic": {

          "toolkit" : "classic",

          "theme"   : "theme-neptune",

    	     "slicer"  : null,

          "requires": [

               "charts"

           ]     

       }

    }

### What to Expect when you are Building

Let's talk about the outcome you would expect based on the `builds` object above.  This `builds` 
config allows you to issue the following build commands from Sencha Cmd:

    // Build modern application only
    sencha app build mymodern

    // Build classic application only
    sencha app build myclassic 

    // Build all targets within the builds object
    sencha app build 

It's important to note that the build target names can be anything you choose.  You could 
replace `mymodern` with `foo`, and then issue:

    sencha app build foo

The resulting `mymodern` application would use the modern toolkit, have access to the ux 
and charts package, and display the Cupertino theme.  

The resulting `myclassic` application would use the classic toolkit, have access to the 
charts package, and display the Neptune theme.

You can create as many variations within the `builds` object as you like.  All output will 
show up in your root level builds folder by default.

### Universal Applications

Universal applications utilize Sencha Cmd to produce multiple application builds spanning 
both toolkits.  These builds result in applications that may be run on Desktop or 
Mobile devices.  It's important to note that a single application **cannot** include 
modern and classic frameworks in a single classpath.  In most cases, an application will 
contain global logic in the traditional application directory; the root level ’app’ folder.  
Ideally, the Universal aspect of the your application will contain data, models, 
viewmodels, etc.  You can also share controllers, though, developers may need to be 
creative in order to produce logic that can span toolkits.  

For instance, let's assume your classic application has a grid, and your modern application 
has a list, and they both consume a shared store and model.  Then, let's say that you'd 
like both applications to react to user interaction with these components.  We must look 
for common events between the grid and the list.  An ideal solution may be to utilize the 
select event, since both components are able to fire it.  However, if your logic included 
"itemtap", your classic application would not know what that meant, and it would most likely 
cause issues during the classic portion of the Cmd build process.

After considering shared logic and resources, developers can then create toolkit specific 
code within the appropriate toolkit src folder.  This is best understood by viewing the 
new Universal application folder structure in Ext JS 6.

**Note:** Folder structure should look quite similar to past implementations if you are 
creating a single toolkit application.

### Ext JS 6 Folder Structure

It's important to note some significant differences in Ext JS 6 and Sencha Cmd 6's new 
directory structure when creating a Universal application.  These changes were made in 
order to ensure applications were able to target three specific areas:

* Global Application Code

* Classic Specific Code

* Modern Specific Code

Here's a representation of a Universal app folder structure:

    // app

         // app

              // model

              // store	

              // view

         // classic

              // src

              // sass

              // resources

         // modern

              // src

              // sass

              // resources

         // resources

         // sass

### Creating a Universal Application

It's simple to get started with a Universal application.  Sencha Cmd now produces a 
"starter app" that contains the appropriate file structure, `app.json`, and examples of 
shared code.  To create your Universal application, generate an application as per usual:

	 sencha -sdk /path/to/ExtSDK generate app MyApp ./MyAppLocation

Sencha Cmd will now create a fully functional Universal application.  This application 
will produce a classic and modern application that both share data that can be found in 
the "app" folder.  Toolkit specific definitions may be found in their respective toolkit 
named folders (modern and classic).

In order to see each application for development, you can target your sencha app watch 
in the same manner as you target your builds.

	 sencha app watch modern 

	 sencha app watch classic

**Note:** Omitting a watch target will default to the first named build in the `builds` object.

Once you've built your application, you can view the builds in their respective browsers.  
For instance, loading the build folder on an iPhone should show you the modern version of 
your application.  Loading it in a desktop browser should show you the classic version 
of your application.

## Runtime Configurations

There are also several ways to use an application’s runtime environment to create 
applications.  These methods include app profile, responsive configs, and platform configs.

Let's explore the possibilities each of them presents and how they can work together to 
provide your users with a seamless experience across many mediums.

### App Profiles

Using `Ext.app.Profile` allows developers to swap out an application's view based on a defined 
criteria via the mainView (or Viewport). This means you can create an entirely different 
view for your application by activating a profile for specific conditions.  For instance, 
you may want to present specific views depending on whether your application is being loaded 
on a Mobile device -vs- a Desktop browser.   

In this case, you would create two profiles and then list them in your profiles array 
found on the Application class.  Here's a simple example of 
such a setup:

 
    Ext.define('App.Application', {
        extend: 'Ext.app.Application',
     
        profiles: [
            'Desktop',
            'Mobile'
        ]
    });

The active profile is determined by the returned value of the `isActive`
method on your profile.  Here's an example of how you could configure an application to 
load the desktop view based on the detected OS.

 
    Ext.define('App.profile.Desktop', {
        extend: 'Ext.app.Profile',
     
        mainView: 'App.view.desktop.Main',
     
        isActive: function () {
            return Ext.os.is.Desktop;
        },
     
        launch: function () {
            console.log('Launch Desktop');
        }
    });
 
Profiles do not have to use the `mainView` config.  Instead, you could use the profile's 
launch method for any further custom processing. Only the active profile’s `launch` method 
will be called.

### Platform Configs

The `platformConfig` property can be used in class 
declarations or to configure object instances based on the current platform or device 
classification. We might use this in a view like so:
 
    Ext.define('App.view.summary.Manufacturing', {
        extend: 'Ext.panel.Panel',
     
        title: 'Mfg Summary',
     
        platformConfig: {
            desktop: {
                title: 'Manufacturing Summary'
            }
        }
    });
 
The above has the same result as the direct approach below:

    Ext.define('App.view.summary.Manufacturing', {
        extend: 'Ext.panel.Panel',
     
        title: testForDesktop ? 'Manufacturing Summary'
                              : 'Mfg Summary'
    });
 

The idea is not to compare the merits of `platformConfig` versus a ternary operator, 
but rather to see that `platformConfig` is treated as part of the class declaration. As 
such, this approach will work regardless of the base class. One reason to prefer 
`platformConfig` over inline logic is to keep a view as data-only which can be safely sent 
in JSON format.

One can also use `platformConfig` to configure instances:

    Ext.define('App.view.summary.Manufacturing', {
        extend: 'Ext.panel.Panel',
     
        items: [{
            xtype: 'panel',
     
            platformConfig: {
                desktop: {
                    title: 'Manufacturing Summary'
                },
                '!desktop': {
                    title: 'Mfg Summary'
                }
            }
        }]
    });

The best direct translation of the above would be:
 
    Ext.define('App.view.summary.Manufacturing', {
        extend: 'Ext.panel.Panel',
     
        items: [
            Ext.merge({
                xtype: 'panel'
            },
            testForDesktop ? {
                title: 'Manufacturing Summary'
            } : {
                title: 'Mfg Summary'
            })
        ]
    });
     
In this use of platformConfig, however, the merging is handled by the `initConfig` 
method. In other words, providing a `platformConfig` property as an instance configuration 
is only supported for classes that call `initConfig` in their constructor. This is the case 
for `Ext.Widget`, `Ext.Component`, most of the data package classes 
(such as AbstractStore), and any class that uses Observable.

Similar to how using `platformConfig` in a class declaration modifies the class body, using 
`platformConfig` on an instance config modifies the initial configuration of the object.

### Responsive Configs

Ext JS 5.0 introduced the `responsiveConfig` and the Responsive Mixin 
and plugin that enables it. `responsiveConfig's` rules and 
properties are not only evaluated when creating instances, but when device orientation or 
viewport size changes. While this adds some overhead compared to `platformConfig`, it is 
likely to be more efficient than handling these yourself by listening to window resize or 
orientation change.

If we adjust our criteria slightly, we can make the title respond to device size instead 
of device classification ("desktop").

 
    Ext.define('App.view.summary.Manufacturing', {
        extend: 'Ext.panel.Panel',
        mixins: ['Ext.mixin.Responsive'],
 
        responsiveConfig: {
            'width >= 600': {
                title: 'Manufacturing Summary'
            },
            'width < 600': {
                title: 'Mfg Summary'
            }
        }
    });
 

Because the above class has a `responsiveConfig`, we benefit from using the mixin here and 
avoid creating a plugin for each instance. When used on a component instance, however, 
we must use the responsive plugin instead:

 
    Ext.define('App.view.summary.Manufacturing', {
        extend: 'Ext.panel.Panel',
     
        items: [{
            xtype: 'panel',
            plugins: 'responsive',
     
            responsiveConfig: {
                'width >= 600': {
                    title: 'Manufacturing Summary'
                },
                'width < 600': {
                    title: 'Mfg Summary'
                }
            }
        }]
    });
 

It is important to remember that width in the above example is viewport width, not 
component width.

## Conclusion

With all these tools at hand, it is just a matter of picking the right tool for the particular 
situation. For simple tuning at load time, there is `platformConfig`. For more dynamic 
conditions, there is `responsiveConfig`. To change things on a larger scale, there is 
`Ext.app.Profile`.

And if you need an application that looks completely different on tablets than it does on 
desktop, or even phones, you could consider Sencha Cmd build profiles. Build profiles can 
remove the tablet overhead from the desktop build and vice versa.

Since there cannot be a "one size fits all" solution, Ext JS provides different tools that 
combine efficiency and flexibility. They each work together to help ensure that your 
application will be a natural fit for the widest possible range of devices.
